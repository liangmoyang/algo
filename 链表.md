# 链表 Linked List
<u>*可跟数组结构做对比来学习</u>

>通过“指针”将一组零碎的内存块串联起来使用。<br>
每一个内存块就是链表的一个结点。<br>
为了将所有结点都连接起来，每个结点除了存储自身的数据之外，还要记录链上的下一个结点的地址，这个记录了下一个结点的指针叫做**后继指针next**

- 不需要连续的内存空间
- 通过指针将这些空间连接到一起，形成“链”

> 链表支持查找、插入和删除

    数组进行插入、删除操作时，为了保持数据的连续性，需要做大量的数据搬移，所以时间的复杂度是O(n)。
    而在链表中进行插入、删除时，并不需要为了保持数据的连续性而搬移结点，因为在链表中的存储空间本就不是连续的，所以速度是非常快速的。
    针对链表的插入、删除操作，只需要考虑该结点的两个相邻结点的指针改变，所以时间的复杂度是O(1)。
    而在“随机访问”中，假设想获取第N位结点时，则需要从头开始遍历获取，所以链表的随机访问性能远没有数组好，时间复杂度为O(n)。

> 最常见的链表结构：单链表、循环链表、双向链表

## 单链表
    第一个结点叫做头结点，最后一个结点叫做尾结点。
    头结点用来记录链表的基地址，有了它就可以遍历整个链表。
    尾结点的next指针指向了一个空地址NULL，表示这是链表的最后一个结点。

## 循环链表
    循环链表是一种特殊的单链表，唯一的区别就是尾结点的不同。
    单链表的尾结点指针指向空地址，表示这是最后的结点；而循环链表的尾结点指向的是自身链表的头结点。（首尾相连）
    适用于具有环形结构特点的数据模型。

## 双向链表
    单链表只有一个方向，每个结点只有一个next指针指向后继的结点。
    双向链表，有两个方向，每个结点不仅有next指针指向后继的结点，还有一个prev指针指向前驱的结点。
    因此，双向链表比单链表要占用更多的空间。

    优：支持双向遍历，提高操作的灵活性
    劣：占用更多空间


> 从结构上看，双向链表支持O(1)时间复杂度的情况下找到前驱结点，因此，双向链表在某些情况下的插入、删除等操作都要比单链表要简单、高效。


## 实际操作
### 删除
    链表中删除数据的两种场景：
    1. 删除结点中“值等于某个给定值”的结点
    2. 删除指定指针的结点

    场景1中，单链表和双向链表都需要从头结点开始依次遍历对比，直到找到给定值的结点，然后通过指针删除结点。此时的删除操作的时间复杂度是O(1),但遍历查找的时间却是O(n) ，所以最终的总时间复杂度是O(n)。

    场景2中，已知需要删除的结点I的位置，但是删除时需要获得其前驱结点的指针，而重点是，单链表并不支持直接获取其前驱结点的指针，所以需要从头结点开始遍历链表，直到找到结点J的next为结点I，则说明J是I的前驱结点。
    而双向链表中的每个结点都保存了前驱结点的指针，不需要遍历查找。因此，在场景2中，单链表操作删除的时间复杂度是O(n)，双向链表的时间复杂度是O(1)。

    同理，在链表的某个指定结点前面插入一个结点，双向链表也比单链表有优势。
    单链表操作插入的时间复杂度是O(n)，双向链表的时间复杂度是O(1)。

    此外，对于一个有序链表，双向链表的按值查询的效率也比单链表要高一些。
    我们可以记录上次查找的位置，每次查询时，根据查询的值与上次的位置比对大小，则可以决定是往前还是往后查找，所以平均只需要查找一般的数据。

    因此，在实际开发过程中，即便双向链表比单项链表要损耗更多的空间，但还是比单链表的应用更加的广泛。




---

## 扩展：
### 经典的应用场景：**缓存的LRU缓存淘汰算法**
    缓存淘汰策略：
    - 先进先出（FIFO）
    - 最少使用策略（LFU）
    - 最近最少使用策略（LRU）

    缓存：空间换时间的设计思想

> **空间换时间**<br>
    当内存空间充足的时候，可以选择空间复杂度相对比较高，但时间复杂度比较低的算法或者数据结构。<br>
    相反，如果内存比较紧缺，就要反过来用时间换空间的设计思路。
    
















